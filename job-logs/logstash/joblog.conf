
input { 
    file {
        path => "./*corrected.csv"
        start_position => "beginning"
        sincedb_path => "."
    }
}

output { 
    if !("_grokparsefailure" in [tags]) {
        elasticsearch {
            host => "uct2-es1.mwt2.org"
            protocol => "http"
            index => "jobsarchived"
            index_type => "job_record"
            cluster => "dataanalytics"
            
        }
#        stdout { codec => rubydebug }
    }
#    if ("_grokparsefailure" in [tags]) {
#        stdout { codec => json }
#    }
}


filter {
    csv {
        columns => ["panda_id",
                    "modification_time",
                    "job_definition_id",
                    "scheduler_id",
                    "pilot_id", 
                    "creation_time",
                    "creation_host",
                    "modification_host",
                    "atlas_release",
                    "transformation",
                    "home_package",
                    "prod_series_label",
                    "prod_source_label",
                    "prod_userid",
                    "assigned_priority",
                    "current_priority",
                    "attempt_number",
                    "max_attempt",
                    "status",
                    "job_name",
                    "max_cpu_count",
                    "max_cpu_unit",
                    "max_disk_count",
                    "max_disk_unit",
                    "ip_connectivity",
                    "min_ram_count",
                    "min_ram_unit",
                    "start_time",
                    "end_time",
                    "cpu_time", 
                    "cpu_consumption_unit",
                    "command_to_pilot",
                    "trans_exit_code",
                    "pilot_error_code",
                    "pilot_error_diag",
                    "junk1",
                    "junk2",
                    "junk3",
                    "junk4",
                    "junk5",
                    "junk6",
                    "junk7",
                    "junk8",
                    "junk9",
                    "junk10",
                    "junk11", 
                    "task_buffer_errordiag",
                    "computing_site",
                    "computing_element",
                    "prod_block",
                    "dispatchd_block",
                    "destinationd_block",
                    "destination_se",
                    "nevents",
                    "junk12",
                    "cloud",
                    "junk13",
                    "junk14",
                    "junk15",
                    "junk16",
                    "task_id",
                    "cmtconfig",
                    "modification_time",
                    "prod_db_update_time",
                    "locked_by",
                    "junk17",
                    "job_execution_id",
                    "vo",
                    "pilot_timing",
                    "working_group",
                    "processing_type",
                    "prod_username",
                    "junk18",
                    "country_group",
                    "batch_id",
                    "junk19",
                    "junk20",
                    "job_set_id",
                    "core_count",
                    "n_input_data_files",
                    "input_file_type",
                    "input_file_project",
                    "input_file_bytes",
                    "n_output_data_files",
                    "output_file_bytes"]
        }

    # convert fields to integers
    mutate {
        convert => [ "panda_id", "integer" ]
        convert => [ "job_definition_id", "integer" ]
        convert => [ "assigned_priority", "integer" ]
        convert => [ "current_priority", "integer" ]
        convert => [ "attempt_number", "integer" ]
        convert => [ "max_attempt", "integer" ]
        convert => [ "max_cpu_count", "integer" ]
        convert => [ "max_disk_count", "integer" ]
        convert => [ "min_ram_count", "integer" ]
        convert => [ "cpu_time", "integer" ]
        convert => [ "trans_exit_code", "integer" ]
        convert => [ "pilot_exit_code", "integer" ]
        convert => [ "nevents", "integer" ]
        convert => [ "task_id", "integer" ]
        convert => [ "job_execution_id", "integer" ]
        convert => [ "job_set_id", "integer" ]
        convert => [ "core_count", "integer" ]
        convert => [ "n_input_data_files", "integer" ]
        convert => [ "input_file_bytes", "integer" ]
        convert => [ "n_output_data_files", "integer" ]
        convert => [ "output_file_bytes", "integer" ]
    }

    # strip fields of whitespace
    mutate {
        strip => [ "ip_connectivity", "max_disk_unit", "min_ram_unit" ]
    }
    
    #split pilot timing fields
    if [pilot_timing] {
        ruby {
            code => "fields = event['pilot_timing'].split(/\|/); event['get_job_consumption'] = fields[0]; event['stage_in_consumption']= fields[1]; event['payload_consumption'] = fields[2]; event['stage_out_consumption'] = fields[3]; event['setup_consumption'] = fields[4]"
            remove_field => ["pilot_timing"]
        }
    }

    # handle units modifiers for disk and ram fields
    if [min_ram_count] and [min_ram_unit] {
        ruby {
            code => "if event['min_ram_unit'] == 'MB'; event['min_ram_count'] = event['min_ram_count'] * 1048576; end"
            remove_field => ["min_ram_unit"]
        }
        ruby {
            code => "if event['min_ram_unit'] == 'GB'; event['min_ram_count'] = event['min_ram_count'] * 1073741824; end"
            remove_field => ["min_ram_unit"]
        }
    }

    if [max_disk_count] and [max_disk_unit] {
        ruby {
            code => "if event['max_disk_unit'] == 'MB'; event['max_disk_count'] = event['max_disk_count'] * 1048576; end"
            remove_field => ["max_disk_unit"]
        }
        ruby {
            code => "if event['max_disk_unit'] == 'GB'; event['max_disk_count'] = event['max_disk_count'] * 1073741824; end"
            remove_field => ["max_disk_unit"]
        }
    }

    # convert fields that ruby filters changed
    mutate {
        convert => [ "get_job_consumption", "integer" ]
        convert => [ "stage_in_consumption", "integer" ]
        convert => [ "payload_consumption", "integer" ]
        convert => [ "stage_out_consumption", "integer" ]
        convert => [ "setup_consumption", "integer" ]
        convert => [ "min_ram_unit", "integer" ]
        convert => [ "max_disk_count", "integer" ]
    }

    

    # create calculated fields
    if [payload_consumption] and [cpu_time] {
        ruby {
            code => "if event['payload_consumption'].to_i == 0
                     then
                       event['job_efficiency'] = nil
                     else
                       event['job_efficiency'] = event['cpu_time'].to_i / event['payload_consumption'].to_i
                     end"
        }
    }

    if [start_time] and [end_time] {
        ruby {
            code => "event['job_duration'] = event['end_time'].to_i - event['start_time'].to_i"
        }
    }

    # convert date fields
    if [modification_time] {
        ruby {
            code => 'require "date"; event["modification_time"]  = DateTime.strptime(event["modification_time"], "%s").iso8601'
        }
    }

    if [creation_time] {
        ruby {
            code => 'require "date"; event["creation_time"]  = DateTime.strptime(event["creation_time"], "%s").iso8601'
        }
    }

    if [start_time] {
        ruby {
            code => 'require "date"; event["start_time"]  = DateTime.strptime(event["start_time"], "%s").iso8601'
        }
    }

    if [end_time] {
        ruby {
            code => 'require "date"; event["end_time"]  = DateTime.strptime(event["end_time"], "%s").iso8601'
        }
    }

    if [prod_db_update_time] {
        ruby {
            code => 'require "date"; event["prod_db_update_time"]  = DateTime.strptime(event["prod_db_update_time"], "%s").iso8601'
        }
    }

    # set timestamp
    date {
        match => ["creation_time", "ISO8601" ]
    }

    # remove unused fields
    mutate {
        remove_field => [ "junk1",
                          "junk2",
                          "junk3",
                          "junk4",
                          "junk5",
                          "junk6",
                          "junk7",
                          "junk8",
                          "junk9",
                          "junk10",
                          "junk11",
                          "junk12",
                          "junk13",
                          "junk14",
                          "junk15",
                          "junk16",
                          "junk17",
                          "junk18",
                          "junk19",
                          "junk20",
                          "column86",
                          "column87"]
    }


}


