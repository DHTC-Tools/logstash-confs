
input { 
#    file {
#        path => "/share/home/sthapa/projects/job-logs/logs/panda-test/panda5.csv"
#        start_position => "beginning"
#    }
    stdin { }
}

output { 
    if !("_grokparsefailure" in [tags]) {
#        elasticsearch {
#            host => "uct2-es1.mwt2.org"
#            protocol => "http"
#            index => "jobsarchived"
#            index_type => "job_record"
#            cluster => "dataanalytics"
#        }
        stdout { codec => rubydebug }
    }
    if ("_grokparsefailure" in [tags]) {
        stdout { codec => json }
    }
}


filter {
    csv {
        columns => ["panda_id",
                    "job_definition_id",
                    "scheduler_id",
                    "pilot_id", 
                    "creation_time",
                    "creation_host",
                    "modification_time",
                    "modification_host",
                    "atlas_release",
                    "transformation",
                    "home_package",
                    "prod_series_label",
                    "prod_source_label",
                    "prod_userid",
                    "assigned_priority",
                    "current_priority",
                    "attempt_number",
                    "max_attempt",
                    "status",
                    "job_name",
                    "max_cpu_count",
                    "max_cpu_unit",
                    "max_disk_count",
                    "max_disk_unit",
                    "ip_connectivity",
                    "min_ram_count",
                    "min_ram_unit",
                    "start_time",
                    "end_time",
                    "cpu_time", 
                    "cpu_consumption_unit",
                    "command_to_pilot",
                    "trans_exit_code",
                    "pilot_error_code",
                    "pilot_error_diag",
                    "exe_error_code",
                    "exe_error_diag",
                    "sup_error_code",
                    "sup_error_diag",
                    "ddm_error_code",
                    "ddm_error_diag",
                    "broker_agree_error_code",
                    "broker_agree_error_diag",
                    "job_dispatcher_error_code",
                    "job_dispatcher_error_diag",
                    "task_buffer_error_code", 
                    "task_buffer_errordiag",
                    "computing_site",
                    "computing_element",
                    "prod_block",
                    "dispatchd_block",
                    "destinationd_block",
                    "destination_se",
                    "nevents",
                    "grid",
                    "cloud",
                    "cpu_conversion",
                    "source_site",
                    "destination_site",
                    "transfer_type",
                    "task_id",
                    "cmt_config",
                    "state_change_time",
                    "prod_db_update_time",
                    "locked_by",
                    "relocation_time",
                    "job_execution_id",
                    "vo",
                    "pilot_timing",
                    "working_group",
                    "processing_type",
                    "job_parameters",
                    "metadata",
                    "prod_username",
                    "n_input_files",
                    "country_group",
                    "batch_id",
                    "parent_id",
                    "special_handling",
                    "job_set_id",
                    "core_count",
                    "n_input_data_files",
                    "input_file_type",
                    "input_file_project",
                    "input_file_bytes",
                    "n_output_data_files",
                    "output_file_bytes",
                    "job_metrics"]
        }

    # convert fields to integers
    mutate {
        convert => [ "panda_id", "integer" ]
        convert => [ "job_definition_id", "integer" ]
        convert => [ "assigned_priority", "integer" ]
        convert => [ "current_priority", "integer" ]
        convert => [ "attempt_number", "integer" ]
        convert => [ "max_attempt", "integer" ]
        convert => [ "max_cpu_count", "integer" ]
        convert => [ "max_disk_count", "integer" ]
        convert => [ "min_ram_count", "integer" ]
        convert => [ "cpu_time", "integer" ]
        convert => [ "trans_exit_code", "integer" ]
        convert => [ "pilot_exit_code", "integer" ]
        convert => [ "nevents", "integer" ]
        convert => [ "task_id", "integer" ]
        convert => [ "job_execution_id", "integer" ]
        convert => [ "job_set_id", "integer" ]
        convert => [ "core_count", "integer" ]
        convert => [ "n_input_data_files", "integer" ]
        convert => [ "input_file_bytes", "integer" ]
        convert => [ "n_output_data_files", "integer" ]
        convert => [ "output_file_bytes", "integer" ]
    }

    # strip fields of whitespace
    mutate {
        strip => [ "ip_connectivity", "max_disk_unit", "min_ram_unit" ]
    }
    
    #split pilot timing fields
    if [pilot_timing] {
        ruby {
            code => "fields = event['pilot_timing'].split(/\|/); event['get_job_consumption'] = fields[0]; event['stage_in_consumption']= fields[1]; event['payload_consumption'] = fields[2]; event['stage_out_consumption'] = fields[3]; event['setup_consumption'] = fields[4]"
            remove_field => ["pilot_timing"]
        }
    }

    # handle units modifiers for disk and ram fields
    if [min_ram_count] and [min_ram_unit] {
        ruby {
            code => "if event['min_ram_unit'] == 'MB'; event['min_ram_count'] = event['min_ram_count'] * 1048576; end"
            remove_field => ["min_ram_unit"]
        }
        ruby {
            code => "if event['min_ram_unit'] == 'GB'; event['min_ram_count'] = event['min_ram_count'] * 1073741824; end"
            remove_field => ["min_ram_unit"]
        }
    }

    if [max_disk_count] and [max_disk_unit] {
        ruby {
            code => "if event['max_disk_unit'] == 'MB'; event['max_disk_count'] = event['max_disk_count'] * 1048576; end"
            remove_field => ["max_disk_unit"]
        }
        ruby {
            code => "if event['max_disk_unit'] == 'GB'; event['max_disk_count'] = event['max_disk_count'] * 1073741824; end"
            remove_field => ["max_disk_unit"]
        }
    }

    # convert fields that ruby filters changed
    mutate {
        convert => [ "get_job_consumption", "integer" ]
        convert => [ "stage_in_consumption", "integer" ]
        convert => [ "payload_consumption", "integer" ]
        convert => [ "stage_out_consumption", "integer" ]
        convert => [ "setup_consumption", "integer" ]
        convert => [ "min_ram_unit", "integer" ]
        convert => [ "max_disk_count", "integer" ]
    }

    

    # create calculated fields
    if [payload_consumption] and [cpu_time] {
        ruby {
            code => "if event['payload_consumption'].to_i == 0
                     then
                       event['job_efficiency'] = nil
                     else
                       event['job_efficiency'] = event['cpu_time'].to_i / event['payload_consumption'].to_i
                     end"
        }
    }

    # convert date fields
    if [modification_time] {
        ruby {
            code => 'require "date"; event["modification_time"]  = DateTime.strptime(event["modification_time"], "%d-%B-%y").iso8601'
        }
    }

    if [creation_time] {
        ruby {
            code => 'require "date"; event["creation_time"]  = DateTime.strptime(event["creation_time"], "%d-%B-%y").iso8601'
        }
    }

    if [start_time] {
        ruby {
            code => 'require "date"; event["start_time"]  = DateTime.strptime(event["start_time"], "%d-%B-%y").iso8601'
        }
    }

    if [end_time] {
        ruby {
            code => 'require "date"; event["end_time"]  = DateTime.strptime(event["end_time"], "%d-%B-%y").iso8601'
        }
    }

    if [prod_db_update_time] {
        ruby {
            code => 'require "date"; event["prod_db_update_time"]  = DateTime.strptime(event["prod_db_update_time"], "%d-%B-%y").iso8601'
        }
    }

    if [start_time] and [end_time] {
        ruby {
            code => "event['job_duration'] = event['end_time'].to_i - event['start_time'].to_i"
        }
    }

    # set timestamp
    date {
        match => ["creation_time", "ISO8601" ]
    }



}


