input { stdin { } }


output {
    if !("_grokparsefailure" in [tags]) {
        elasticsearch {
            protocol => "http"
            host => "uct2-es-door.mwt2.org"
            index => "DCACHE_INDEX"
            index_type => "%{record_type}"
            cluster => "dataanalytics"

        }
#        stdout { codec => rubydebug }
    }
#    if ("_grokparsefailure" in [tags]) {
#        stdout { codec => json }
#    }
}


# MoverInfoMessage filter
filter {
    if ![record_type] {
        grok {
            patterns_dir => "./patterns"
            match => { "message" => "%{TIMESTAMP_ISO8601:timestamp} \[%{WORD:cell_type}:%{CELLNAME:cell_name}:%{WORD:request_type}\] \[%{BASE16NUM:pnfs_id},%{INT:filesize:int}] \[%{DCACHE_PATH:path}\] %{WORD:storage_name}:%{WORD:storage_group}@%{WORD:storage_type} %{INT:bytes_transferred:int} %{INT:connection_time:int} %{WORD:created} \{%{PROTOCOL:protocol}\} \[%{INITIATOR:initiator}\] \{%{INT:result_code:int}:%{QS:message}\}"}
        }

        date {
            remove_field => timestamp
            match => ["timestamp", "ISO8601"]
        }
        if [bytes_transferred] {
            mutate {
                add_field => ["record_type", "mover_message"]
            }
        }
    }
}

# RemoveFileInfoMessage filter
filter {
    if ![record_type] {
        grok {
            patterns_dir => "./patterns"
            match => { "message" => "%{TIMESTAMP_ISO8601:timestamp} \[%{WORD:cell_type}:%{CELLNAME:cell_name}:%{WORD:request_type}\] \[%{BASE16NUM:pnfs_id},%{INT:filesize:int}\] \[%{DCACHE_PATH:path}\] \{%{INT:result_code:int}:%{QS:message}\}"}
        }

        if !("_grokparsefailure" in [tags]) {
            mutate {
                add_field => ["record_type", "remove_message"]
            }
        }
    }
}

# DoorRequestInfoMessage filter
filter {
    if ![record_type] {
        grok {
            patterns_dir => "./patterns"
            match => { "message" => "%{TIMESTAMP_ISO8601:timestamp} \[%{WORD:cell_type}:%{CELLNAME:cell_name}:%{WORD:request_type}\] \[%{QS:owner}:%{INT:uid:int}:%{INT:gid:int}:%{IP:client}\] \[%{BASE16NUM:pnfs_id},%{INT:filesize:int}\] \[%{DCACHE_PATH:path}\] %{WORD:storage_name}:%{WORD:storage_group}@%{WORD:storage_type} %{INT:transaction_time:int} %{INT:queuing_time:int} \{%{INT:result_code:int}:%{QS:message}\}"}
        }

        date {
            remove_field => timestamp
            match => ["timestamp", "ISO8601"]
        }
        if [owner] {
            mutate {
                add_field => ["record_type", "door_request"]
            }
        }
    }
}

# StorageInfoMessage filter
filter {
    if ![record_type] {
        grok {
            patterns_dir => "./patterns"
            match => { "message" => "%{TIMESTAMP_ISO8601:timestamp} \[%{WORD:cell_type}:%{WORD:cell_name}:%{WORD:request_type}\] \[%{BASE16NUM:pnfs_id},%{INT:filesize:int}] \[%{DCACHE_PATH:path}\] %{INT:transfer_time:int} %{INT:queuing_time:int} \{%{INT:result_code:int}:%{QS:message}\}"}
        }

        date {
            remove_field => timestamp
            match => ["timestamp", "ISO8601"]
        }
        if [transfer_time] {
            mutate {
                add_field => ["record_type", "storage_message"]
            }
        }
    }
}

